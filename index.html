<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory RAM: Verification Mode</title>
    <style>
        :root {
            --neon-green: #0f0;
            --neon-blue: #00f3ff;
            --neon-red: #ff3333;
            --dark-bg: #0d0d0d;
            --panel-bg: #1a1a1a;
            --selected: #ff00ff;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--neon-green);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-align: center;
            user-select: none;
        }

        /* --- HUD --- */
        #hud {
            position: fixed; top: 0; width: 100%; padding: 15px;
            background: #000; border-bottom: 1px solid var(--neon-green);
            display: flex; justify-content: space-between;
            font-size: 1.2rem; font-weight: bold; z-index: 100;
        }

        .container { width: 95%; max-width: 900px; margin-top: 80px; display: flex; flex-direction: column; align-items: center; }

        .hidden { display: none !important; }

        /* Memorize Items */
        #sequence-display { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 50px; }
        .mem-item {
            background: var(--panel-bg); border: 2px solid var(--neon-green);
            padding: 20px; font-size: 1.5rem; border-radius: 5px;
            box-shadow: 0 0 10px var(--neon-green); animation: fadeIn 0.5s;
        }

        /* Distraction */
        #distract-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .glitch-text {
            font-size: 4rem; font-weight: bold; color: white;
            animation: glitch 0.2s infinite; text-shadow: 2px 2px red, -2px -2px blue;
        }

        /* Recall */
        #slots-container { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 20px; width: 100%; }
        .slot {
            width: 90px; height: 50px; border: 2px dashed #555;
            display: flex; justify-content: center; align-items: center;
            font-size: 0.8rem; color: white; background: rgba(255,255,255,0.05);
            position: relative; cursor: pointer;
        }
        .slot.active { border: 2px solid var(--selected); box-shadow: 0 0 10px var(--selected); }
        .slot.filled { border: 2px solid var(--neon-blue); color: var(--neon-blue); }
        .slot-number { position: absolute; top: -18px; left: 0; font-size: 0.7rem; color: #777; }

        #word-bank { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; max-width: 800px; padding-top: 20px; border-top: 1px solid #333; }
        .bank-btn {
            background: #222; color: #aaa; border: 1px solid #444; padding: 8px 15px;
            cursor: pointer; font-family: inherit; font-size: 0.9rem;
        }
        .bank-btn:hover:not(:disabled) { background: #444; color: white; }
        .bank-btn:disabled { opacity: 0.2; text-decoration: line-through; cursor: default; }

        #btn-submit {
            margin-top: 20px; padding: 15px 40px; font-size: 1.2rem;
            background: var(--neon-green); color: black; border: none; cursor: pointer; font-weight: bold;
        }

        /* --- RESULTS TABLE --- */
        #game-over { width: 100%; max-width: 800px; padding-bottom: 50px; }
        .results-table {
            width: 100%; border-collapse: collapse; margin-top: 20px;
            font-size: 0.9rem; text-align: left;
        }
        .results-table th { border-bottom: 1px solid var(--neon-green); padding: 10px; color: var(--neon-green); }
        .results-table td { border-bottom: 1px solid #333; padding: 8px; color: #ccc; }
        
        .res-correct { color: var(--neon-green) !important; }
        .res-wrong { color: var(--neon-red) !important; text-decoration: line-through; }
        .res-missed { color: var(--neon-blue) !important; font-weight: bold; }

        /* EXIT BUTTON */
        #btn-exit {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 1rem;
            background: white;
            color: black;
            border: none;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 15px white;
            animation: pulse 2s infinite;
        }
        
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
        }

        @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="color:white; margin-bottom:10px;">üß† MEMORY RAM</h1>
        <p style="color:#777; margin-bottom: 30px;">Turn volume UP. Click to Initialize.</p>
        <button onclick="startGame()" style="padding:15px 30px; font-size:1.5rem; cursor:pointer; background:var(--neon-green); border:none; font-weight:bold;">INITIALIZE SYSTEM</button>
    </div>

    <div id="hud">
        <span id="phase-label">IDLE</span>
        <span>‚è±Ô∏è <span id="timer-display">00.0</span>s</span>
    </div>

    <div class="container">
        <div id="sequence-display" class="hidden"></div>

        <div id="distract-layer" class="hidden">
            <div class="glitch-text">SYSTEM FAILURE</div>
        </div>

        <div id="recall-ui" class="hidden">
            <div id="slots-container"></div>
            <div id="word-bank"></div>
            <button id="btn-submit" onclick="submitData()">VERIFY INTEGRITY</button>
        </div>

        <div id="game-over" class="hidden">
            <h1>SYSTEM REPORT</h1>
            <h2 style="margin: 5px 0;">SCORE: <span id="final-score" style="color:white; font-size:2rem;">0</span></h2>
            
            <table class="results-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>User Input</th>
                        <th>Actual Data</th>
                        <th>Time (s)</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                    </tbody>
            </table>
            
            <button id="btn-exit" onclick="sendToHubNow()">UPLOAD SCORE & EXIT (60s)</button>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const DATA_POOL = [
            "CPU", "RAM", "BIOS", "JAVA", "HTML", "CSS", "NODE", "DATA", "WIFI", "CACHE", "LOGIN", "USER",
            "1990", "2000", "2024", "2077", "1080p", "4K", "MP3", "PNG", "GIF", "JPEG", "TIFF", "RAW",
            "üíæ", "üñ±Ô∏è", "üíø", "üîã", "ü§ñ", "üëæ", "üì±", "üì°", "üîë", "üîí", "üíä", "üí£", "‚ö°", "‚ö†Ô∏è", "üëÅÔ∏è",
            "LINUX", "WIN", "MAC", "CODE", "BUG", "LOOP", "IF", "ELSE", "VAR", "CONST", "NULL", "VOID"
        ];

        const urlParams = new URLSearchParams(window.location.search);
        const SEED = parseInt(urlParams.get('seed')) || 12345;
        const COUNT = parseInt(urlParams.get('count')) || 5; 
        const TIME_MEM = Math.max(1, parseInt(urlParams.get('memTime')) || 5);
        const TIME_DIST = Math.max(1, parseInt(urlParams.get('distTime')) || 4);
        const TIME_ANS = Math.max(5, parseInt(urlParams.get('ansTime')) || 45);

        // --- STATE ---
        let currentSeed = SEED;
        let targetSequence = [];
        let bankWords = [];
        let userAnswers = []; 
        let selectedSlotIndex = null;
        let recallStartTime = 0;
        let timerInterval;
        let exitTimerInterval;
        let calculatedFinalScore = 0;
        let isScoreSent = false;
        
        let audioCtx;
        let isAudioInit = false;

        function seededRandom() {
            var x = Math.sin(currentSeed++) * 10000;
            return x - Math.floor(x);
        }

        function shuffleSeeded(array) {
            for(let i = array.length - 1; i > 0; i--){
                const j = Math.floor(seededRandom() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startGame() {
            if (!isAudioInit) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioCtx.state === 'suspended') audioCtx.resume();
                    isAudioInit = true;
                } catch (e) { console.warn("Audio not supported"); }
            }

            document.getElementById('start-overlay').classList.add('hidden');
            let pool = shuffleSeeded([...DATA_POOL]);
            targetSequence = pool.slice(0, COUNT);
            let decoys = pool.slice(COUNT, COUNT * 2);
            bankWords = shuffleSeeded([...targetSequence, ...decoys]);
            userAnswers = new Array(COUNT).fill(null);

            startPhaseMemorize();
        }

        function startPhaseMemorize() {
            setPhaseUI("MEMORIZE");
            const container = document.getElementById('sequence-display');
            container.classList.remove('hidden');
            container.innerHTML = '';
            targetSequence.forEach(word => {
                let div = document.createElement('div');
                div.className = 'mem-item';
                div.innerText = word;
                container.appendChild(div);
            });
            runTimer(TIME_MEM, () => {
                container.classList.add('hidden');
                startPhaseDistract();
            });
        }

        function startPhaseDistract() {
            setPhaseUI("ERROR // CORRUPTION");
            document.getElementById('distract-layer').classList.remove('hidden');
            playGlitchSound();
            runTimer(TIME_DIST, () => {
                document.getElementById('distract-layer').classList.add('hidden');
                startPhaseRecall();
            });
        }

        function startPhaseRecall() {
            setPhaseUI("RESTORE DATA");
            document.getElementById('recall-ui').classList.remove('hidden');
            renderSlots();
            renderBank();
            recallStartTime = Date.now();
            runTimer(TIME_ANS, submitData);
        }

        function playGlitchSound() {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            for(let i=0; i < 10; i++) {
                const randomTime = audioCtx.currentTime + (Math.random() * TIME_DIST);
                const randomFreq = 200 + (Math.random() * 800);
                osc.frequency.linearRampToValueAtTime(randomFreq, randomTime);
            }
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + TIME_DIST);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + TIME_DIST);
        }

        function runTimer(seconds, onComplete) {
            clearInterval(timerInterval);
            const endTime = Date.now() + (seconds * 1000);
            updateTimerDisplay(seconds); 
            timerInterval = setInterval(() => {
                const now = Date.now();
                const remaining = (endTime - now) / 1000;
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('timer-display').innerText = "0.0";
                    onComplete();
                } else {
                    updateTimerDisplay(remaining);
                }
            }, 100);
        }

        function updateTimerDisplay(val) {
            document.getElementById('timer-display').innerText = val.toFixed(1);
        }

        function setPhaseUI(text) {
            document.getElementById('phase-label').innerText = text;
        }

        function renderSlots() {
            const container = document.getElementById('slots-container');
            container.innerHTML = '';
            for(let i=0; i<COUNT; i++) {
                let slot = document.createElement('div');
                slot.className = 'slot';
                if(i === selectedSlotIndex) slot.classList.add('active');
                if(userAnswers[i]) {
                    slot.classList.add('filled');
                    slot.innerText = userAnswers[i].word;
                } else {
                    slot.innerText = "";
                }
                let num = document.createElement('span');
                num.className = 'slot-number';
                num.innerText = i + 1;
                slot.appendChild(num);
                slot.onclick = () => { selectedSlotIndex = (selectedSlotIndex === i ? null : i); renderSlots(); };
                container.appendChild(slot);
            }
        }

        function renderBank() {
            const container = document.getElementById('word-bank');
            container.innerHTML = '';
            bankWords.forEach(word => {
                let btn = document.createElement('button');
                btn.className = 'bank-btn';
                btn.innerText = word;
                const isUsed = userAnswers.some(ans => ans && ans.word === word);
                if(isUsed) btn.disabled = true;
                btn.onclick = () => handleBankClick(word);
                container.appendChild(btn);
            });
        }

        function handleBankClick(word) {
            if (selectedSlotIndex === null) return;
            const timeOffset = (Date.now() - recallStartTime) / 1000;
            userAnswers[selectedSlotIndex] = { word: word, time: timeOffset };
            let nextEmpty = -1;
            for(let i=0; i<COUNT; i++) {
                if(!userAnswers[i]) { nextEmpty = i; break; }
            }
            selectedSlotIndex = nextEmpty;
            renderSlots();
            renderBank();
        }

        function submitData() {
            clearInterval(timerInterval);
            document.getElementById('recall-ui').classList.add('hidden');
            document.getElementById('game-over').classList.remove('hidden');

            calculatedFinalScore = 0;
            const tbody = document.getElementById('results-body');
            tbody.innerHTML = '';

            for(let i=0; i<COUNT; i++) {
                const ans = userAnswers[i]; 
                const target = targetSequence[i]; 
                const tr = document.createElement('tr');
                tr.innerHTML += `<td>${i+1}</td>`;
                const userWord = ans ? ans.word : "[EMPTY]";
                const userTime = ans ? ans.time.toFixed(2) : "--";
                let statusHtml = "";
                
                if (ans && ans.word === target) {
                    tr.innerHTML += `<td class="res-correct">${userWord}</td>`;
                    statusHtml = "<span style='color:#0f0'>‚úì PASS</span>";
                    let speedBonus = Math.max(0, Math.floor((TIME_ANS - ans.time) * 10));
                    calculatedFinalScore += (1000 + speedBonus);
                } else {
                    tr.innerHTML += `<td class="res-wrong">${userWord}</td>`;
                    statusHtml = "<span style='color:red'>‚úó FAIL</span>";
                }
                tr.innerHTML += `<td class="res-missed">${target}</td>`;
                tr.innerHTML += `<td>${userTime}</td>`;
                tr.innerHTML += `<td>${statusHtml}</td>`;
                tbody.appendChild(tr);
            }

            document.getElementById('final-score').innerText = calculatedFinalScore;
            
            // --- NEW: Start Exit Timer instead of sending immediately ---
            startExitTimer();
        }

        function startExitTimer() {
            let secondsLeft = 60;
            const btn = document.getElementById('btn-exit');
            
            btn.innerText = `UPLOAD SCORE & EXIT (${secondsLeft}s)`;
            
            exitTimerInterval = setInterval(() => {
                secondsLeft--;
                btn.innerText = `UPLOAD SCORE & EXIT (${secondsLeft}s)`;
                
                if (secondsLeft <= 0) {
                    sendToHubNow();
                }
            }, 1000);
        }

        function sendToHubNow() {
            if (isScoreSent) return;
            isScoreSent = true;
            clearInterval(exitTimerInterval);
            
            document.getElementById('btn-exit').innerText = "DATA UPLOADED.";
            document.getElementById('btn-exit').disabled = true;

            console.log("üì§ Sending score:", calculatedFinalScore);
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score: calculatedFinalScore } }, '*');
        }

    </script>
</body>
</html>