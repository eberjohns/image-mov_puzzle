<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slider Puzzle Challenge</title>
    <style>
        :root {
            --tile-size: 100px;
            --gap: 5px;
            --bg-color: #2c3e50;
            --tile-color: #34495e;
            --accent: #e74c3c;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            background-color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            user-select: none;
        }

        h2 { margin-top: 0; color: var(--bg-color); }

        /* HUD */
        #hud {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--bg-color);
        }

        /* Puzzle Container */
        #puzzle-container {
            width: 310px; /* 3 * 100 + 2 * 5 */
            height: 310px;
            position: relative;
            background: var(--bg-color);
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        /* Individual Tiles */
        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            position: absolute;
            background-image: url(images/image.png); /* background-image: url('https://picsum.photos/300/300'); for random images */
            background-size: 300px 300px; /* Matches container size approx */
            cursor: pointer;
            transition: top 0.2s, left 0.2s;
            border-radius: 4px;
            box-sizing: border-box;
            border: 2px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tile.empty {
            background: transparent;
            border: none;
            cursor: default;
        }

        /* Game Over Screen */
        #game-over {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(44, 62, 80, 0.95);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .hidden { display: none !important; }
        
        .btn-start {
            margin-top: 20px;
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
    </style>
</head>
<body>

    <div id="game-ui">
        <h2>üß© PUZZLE RUSH</h2>
        
        <div id="hud">
            <span>‚è±Ô∏è <span id="timer">0</span>s</span>
            <span>üë£ Moves: <span id="moves">0</span></span>
        </div>

        <div id="puzzle-container">
            </div>
    </div>

    <div id="game-over" class="hidden">
        <h1>Puzzle Solved!</h1>
        <p>Time: <span id="final-time">0</span>s</p>
        <p>Moves: <span id="final-moves">0</span></p>
        <h2 style="color:#f1c40f">Score: <span id="final-score">0</span></h2>
        <p>Sending to Hub...</p>
    </div>

    <script>
        // --- CONFIGURATION ---
        const ROWS = 3;
        const COLS = 3;
        const TILE_SIZE = 100; 
        const GAP = 5; 

        // 1. Get the parameters from the URL
        const urlParams = new URLSearchParams(window.location.search);

        // 2. Set Seed: Check URL for 'seed', otherwise use default 12345
        // We ensure it's a number using parseInt
        const urlSeed = parseInt(urlParams.get('seed'));
        const GAME_SEED = isNaN(urlSeed) ? 12345 : urlSeed;

        // 3. Set Image: Check URL for 'img', otherwise use default Cat image
        const urlImg = urlParams.get('img');
        const defaultImg = 'https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?ixlib=rb-4.0.3&auto=format&fit=crop&w=300&q=80';
        const IMAGE_URL = urlImg ? urlImg : defaultImg;

        // --- STATE ---
        let tiles = []; 
        let emptyTileIndex = { r: 2, c: 2 }; 
        let timeElapsed = 0;
        let moveCount = 0;
        let timerInterval;
        let isGameActive = true;

        // Internal seed tracker
        let currentSeed = GAME_SEED;

        const container = document.getElementById('puzzle-container');

        // --- FAIRNESS CHANGE 3: SEEDED RANDOM FUNCTION ---
        // This function replaces Math.random(). 
        // It generates the same sequence of numbers based on currentSeed.
        function seededRandom() {
            var x = Math.sin(currentSeed++) * 10000;
            return x - Math.floor(x);
        }

        // --- INITIALIZATION ---
        function initGame() {
            createTiles();
            shuffleBoard();
            startTimer();
        }

        function createTiles() {
            container.innerHTML = '';
            tiles = [];
            
            for (let r = 0; r < ROWS; r++) {
                tiles[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (r === ROWS - 1 && c === COLS - 1) {
                        tiles[r][c] = null;
                        continue;
                    }

                    let tile = document.createElement('div');
                    tile.className = 'tile';
                    setPosition(tile, r, c);

                    // Use the static IMAGE_URL variable
                    tile.style.backgroundImage = `url('${IMAGE_URL}')`; 
                    tile.style.backgroundPosition = `-${c * TILE_SIZE}px -${r * TILE_SIZE}px`;
                    
                    tile.dataset.correctR = r;
                    tile.dataset.correctC = c;
                    
                    tile.onclick = () => handleTileClick(r, c);

                    container.appendChild(tile);
                    tiles[r][c] = tile;
                }
            }
            tiles[ROWS-1][COLS-1] = null;
            emptyTileIndex = { r: ROWS-1, c: COLS-1 };
        }

        function setPosition(element, r, c) {
            element.style.top = (r * (TILE_SIZE + GAP)) + 'px';
            element.style.left = (c * (TILE_SIZE + GAP)) + 'px';
        }

        function shuffleBoard() {
            isGameActive = false; 
            
            // Reset the seed so the shuffle is the same every time the page loads
            currentSeed = GAME_SEED;

            for (let i = 0; i < 150; i++) {
                const neighbors = getNeighbors(emptyTileIndex.r, emptyTileIndex.c);
                
                // USE seededRandom() INSTEAD OF Math.random()
                const randomIndex = Math.floor(seededRandom() * neighbors.length);
                const randomNeighbor = neighbors[randomIndex];
                
                swapTiles(randomNeighbor.r, randomNeighbor.c);
            }
            
            moveCount = 0; 
            document.getElementById('moves').innerText = 0;
            isGameActive = true;
        }

        function getNeighbors(r, c) {
            const neighbors = [];
            if (r > 0) neighbors.push({ r: r - 1, c: c });
            if (r < ROWS - 1) neighbors.push({ r: r + 1, c: c });
            if (c > 0) neighbors.push({ r: r, c: c - 1 });
            if (c < COLS - 1) neighbors.push({ r: r, c: c + 1 });
            return neighbors;
        }

        function handleTileClick(clickedR, clickedC) {
            if (!isGameActive) return;

            let currR, currC;
            for(let r=0; r<ROWS; r++){
                for(let c=0; c<COLS; c++){
                    if(tiles[r][c] && tiles[r][c].dataset.correctR == clickedR && tiles[r][c].dataset.correctC == clickedC) {
                        currR = r;
                        currC = c;
                    }
                }
            }
            
            if (isAdjacent(currR, currC, emptyTileIndex.r, emptyTileIndex.c)) {
                swapTiles(currR, currC);
                moveCount++;
                document.getElementById('moves').innerText = moveCount;
                checkWin();
            }
        }

        function isAdjacent(r1, c1, r2, c2) {
            return (Math.abs(r1 - r2) + Math.abs(c1 - c2)) === 1;
        }

        function swapTiles(r, c) {
            const tile = tiles[r][c];
            const emptyR = emptyTileIndex.r;
            const emptyC = emptyTileIndex.c;
            setPosition(tile, emptyR, emptyC);
            tiles[emptyR][emptyC] = tile;
            tiles[r][c] = null;
            emptyTileIndex = { r: r, c: c };
        }

        function checkWin() {
            if (!isGameActive) return;
            let solved = true;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const tile = tiles[r][c];
                    if (tile) {
                        const correctR = parseInt(tile.dataset.correctR);
                        const correctC = parseInt(tile.dataset.correctC);
                        if (r !== correctR || c !== correctC) solved = false;
                    }
                }
            }
            if (solved) gameWin();
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                timeElapsed++;
                document.getElementById('timer').innerText = timeElapsed;
            }, 1000);
        }

        function gameWin() {
            isGameActive = false;
            clearInterval(timerInterval);
            let score = 10000 - (timeElapsed * 10) - (moveCount * 5);
            if (score < 0) score = 0;

            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('final-time').innerText = timeElapsed;
            document.getElementById('final-moves').innerText = moveCount;
            document.getElementById('final-score').innerText = score;

            submitScoreToHub(score);
        }

        function submitScoreToHub(finalScore) {
            console.log("üì§ Sending score to hub:", finalScore);
            window.parent.postMessage({ 
                type: 'GAME_OVER', 
                payload: { score: finalScore } 
            }, '*');
        }

        window.onload = initGame;
    </script>
</body>
</html>